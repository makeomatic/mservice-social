<<<<<<< HEAD
const { NotSupportedError } = require('common-errors');
const { omit, clone, keys } = require('lodash');

class Feed {
  constructor(storage, networks, logger) {
=======
const Errors = require('common-errors');
const Promise = require('bluebird');
const instagramRegisterStrategy = require('./feed/register/instagram');
const twitterRegisterStrategy = require('./feed/register/twitter');

class Feed {
  constructor(storage, twitter, logger, knex) {
>>>>>>> master
    this.storage = storage;
    this.networks = networks;
    this.logger = logger;
    this.knex = knex;
  }

<<<<<<< HEAD
  _hasNetwork(network) {
    if (this._networkList === undefined) {
      this._networkList = keys(this.networks);
    }

    return this._networkList.indexOf(network) >= 0;
  }

  async register(data) {
    if (!this._hasNetwork(data.network)) {
      throw new NotSupportedError(`${data.network} is not currently supported`);
    }

    const { storage, networks, logger } = this;
    const network = networks[data.network];

    const accounts = data.filter.accounts;
    const original = omit(data, 'filter');
    // must return array of account objects: { id, username }
    const expandedAccounts = await network.expandAccounts(accounts);

    for (let i = 0; i < accounts.length; i += 1) {
      const feed = clone(original);

      feed.network_id = expandedAccounts[i].id;
      feed.meta = JSON.stringify({
        account_id: feed.network_id,
        account: expandedAccounts[i].username,
        access_token: expandedAccounts[i].access_token,
      });

      // wait till storage is registered
      await storage.registerFeed(feed);

      // sync feed
      await network.syncAccount(expandedAccounts[i]);
    }

    // start listening
    await network.refresh();

    // log that we finished
    logger.info(`Registered ${expandedAccounts.length} accounts`);

    return expandedAccounts;
=======
  getByNetworkId(network, networkId) {
    return this.knex(Feed.FEED_TABLE)
      .where('network', network)
      .where('network_id', networkId)
      .first();
  }

  register(data) {
    const promise = Promise.bind(this, data);

    if (data.network === 'twitter') {
      return promise.then(twitterRegisterStrategy);
    }

    if (data.network === 'instagram') {
      return promise.then(instagramRegisterStrategy);
    }

    throw new Errors.NotImplementedError(`'feed.register' for '${data.network}'`);
>>>>>>> master
  }

  list(data) {
    return this.storage.listFeeds(data);
  }

  read(data) {
    return this.storage.readStatuses(data);
  }

<<<<<<< HEAD
  async remove(data) {
    const { storage, networks } = this;
    const feed = await storage.listFeeds({ filter: data });
    if (feed.length === 0) {
      return;
    }
=======
  remove(data) {
    const { storage, twitter } = this;
    const process = Promise.coroutine(function* action() {
      const feed = yield storage.listFeeds({ filter: data });
      if (feed.length === 0) {
        return;
      }

      const { meta: { account } } = feed[0];
      yield storage.removeFeed(data);
>>>>>>> master

    const { meta: { account } } = feed[0];
    await storage.removeFeed(data);

    if (!data.keep_data) {
      await storage.removeStatuses({ account, network: data.network });
    }

    if (data.network && networks[data.network]) {
      await networks[data.network].refresh();
    }
  }
}

Feed.FEED_TABLE = 'feeds';

module.exports = Feed;
